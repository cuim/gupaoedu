# MySQL性能优化

## 索引

索引是为了加速对表中数据行的检索而创建的一种分散存储的数据结构。

为什么要用索引？

* 索引能极大的减少存储引擎需要扫描的数据量。

* 索引可以把随机IO变成顺序IO。

* 索引可以帮助我们在进行分组、排序等操作时，避免使用临时表。

### 二叉查找树

###平衡二叉查找树

### 多路平衡查找树(B-Tree)

###加强版的多路平衡查找树B+Tree

### MySQL中B+Tree索引体现形式-Myisam

### MySQL中B+Tree索引体现形式-Innodb

以主键为索引来组织数据的存储

聚集索引

数据库表行中数据的物理顺序与键值的逻辑（索引）顺序相同。

主键索引和辅助索引

### 索引的补充知识

#### 列的离散性

count(distinct col):count(col)

离散性越高；选择性就越好。

#### 最左匹配原则

对索引中关键字进行计算，一定是从左往右依次进行，且不可跳过。

#### 联合索引

单列索引

​	节点中关键字（name）

联合索引

​	节点中关键字（name、phoneName）

单列索引是特殊的联合索引

联合索引列选择原则：

1、经常用的列优先【最左匹配原则】

2、选择性高（离线读）的列优先【离散度高原则】

3、宽度小的列优先【最少空间原则】

#### 覆盖索引

如果查询列可通过索引节点中的关键字直接返回，则该索引称之为覆盖索引。覆盖索引可减少数据库IO，将随机IO变为顺序IO，可提高查询性能。

```
#对name列建立索引
select name, phoneNum form user where name = ?

```

### 总结

索引类的数据长度能少则少。

匹配列前缀可用到索引，如：like 9999%，like %9999%、like %9999 用不到索引；where 条件中 not in 和<> 操作无法使用索引；匹配范围值，order by 也可用的索引；多用指定列查询，只返回自己想得到的数据列，少用select *；

联合索引中如果不是按照索引最左列开始查找，无法使用索引；

联合索引中精准匹配最左前列并范围匹配另外一列可以用到索引；

联合索引中如果查询中有某个列的范围查询，则其右边的所有列都无法使用索引；

## MySQL体系结构

![无标题1](/Users/denny/Desktop/无标题1.png)

### MySQL插拔式的存储引擎

### 存储引擎介绍

* 插拔式的插件方式 

* 存储引擎是指定在表之上的，即一个库中的每一个表都可以指定专用的存储引擎。 
* 不管表采用什么样的存储引擎，都会在数据区，产生对应 的一个**frm**文件(表结构定义描述文件) 。

### CSV存储引擎

数据存储以**CSV**文件

特点: 

​	不能定义没有索引、列定义必须为NOT NULL、不能设置自增列 -->不适用大表或者数据的在线处理 

​	CSV数据的存储用,隔开，可直接编辑CSV文件进行数据的编排 -->数据安全性低 

​	注:编辑之后，要生效使用flush table XXX 命令 

应用场景: 

​	数据的快速导出导入 表格直接转换成**CSV** 

### Archive存储引擎

压缩协议进行数据的存储 

数据存储为**ARZ**文件格式 

特点: 

​	只支持insert和select两种操作 只允许自增ID列建立索引 行级锁
 	不支持事务 

​	数据占用磁盘少 

应用场景: 

​	日志系统 

​	大量的设备数据采集 

### Memory|heap存储引擎

数据都是存储在内存中，**IO**效率要比其他引擎高很多 

服务重启数据丢失，内存数据表默认只有**16M** 

特点: 

​	支持hash索引，B tree索引，默认hash(查找复杂度0(1)) 字段长度都是固定长度varchar(32)=char(32) 不支持	大数据存储类型字段如 blog，text表级锁 

应用场景: 

​	等值查找热度较高数据 

​	查询结果内存中的计算，大多数都是采用这种存储引擎 作为临时表存储需计算的数据 。

### Myisam

Mysql5.5版本之前的默认存储引擎 较多的系统表也还是使用这个存储引擎，系统临时表也会用到Myisam存储引擎。

特点: 

* select count(*) from table 无需进行数据的扫描 
* 数据(MYD)和索引(MYI)分开存储 
* 表级锁
* 不支持事务 	

### Innodb

Mysql5.5及以后版本的默认存储引擎。

* 支持事务ACID
* 行级锁
* 聚集索引(主键索引)方式进行数据存储
* 支持外键关系保证数据完整性

* MVCC(高并发下多版本支持)

### 查询优化-查询执行的路径

![无标题2](/Users/denny/Desktop/无标题2.png)

1、MySQL客户端/服务端通信

​	MySQL客户端/服务端通信方式是“半双工”。

​	MySQL通讯特点和限制：

​		客户端一旦开发送法消息另一端要接收完整个消息才能响应。

​		客户端一旦开始接收数据没法停下来发送指令。

​       MySQL客户端/服务端通信-查询状态

​	对于一个mysql连接，或者说一个线程，时刻都有一个状态来标识这个连接正在做什么
​	查看命令:

​	show full processlist / show processlist

​        状态：

​	Sleep   ->线程正在等待客户端发送数据

​	Query  ->连接线程正在执行查询 

​	Locked ->线程正在等待表锁的释放 

​	Sorting result ->线程正在对结果进行排序 

​	Sending data ->向请求端返回数据

​	可通过kill {id}的方式进行连接的杀掉

2、查询缓存

​	工作原理:
 	缓存SELECT操作的结果集和SQL语句; 新的SELECT语句，先去查询缓存，判断是否存在可用的记录集; 

​	判断标准: 与缓存的SQL语句，是否完全一样，区分大小写 

​	(简单认为存储了一个key-value结构，key为sql，value为sql查询结果集) 

​        查看缓存：

        ```
show variables like 'query_cache%';
        ```

​	query_cache_type（在总配置文件配置my.cnf）
 		值:0 -– 不启用查询缓存，默认值;
 		值:1 -– 启用查询缓存，只要符合查询缓存的要求，客户端的查询语句和记录集 都可以缓存起来，供其他

​                            客户端使用，加上 SQL_NO_CACHE将不缓存。如：

                             ```sql
select sql_no_cache * from users where id = 33;
                             ```

 		值:2 -– 启用查询缓存，只要查询语句中添加了参数:SQL_CACHE，且符合查询缓存的要求，客户端的查

​                             询语句和记录集，则可以缓存起来，供其他客户端使用。

​	query_cache_size：允许设置query_cache_size的值最小为40K，默认1M，推荐设置 为:64M/128M; 

​	query_cache_limit：限制查询缓存区最大能缓存的查询记录集，默认设置为1M 

​	show status like 'Qcache%'：命令可查看缓存情况
 	

 不会缓存的情况：

* 当查询语句中有一些不确定的数据时，则不会被缓存。如包含函数NOW()， CURRENT_DATE()等类似的函

  数，或者用户自定义的函数，存储函数，用户变 量等都不会被缓存。

* 当查询的结果大于query_cache_limit设置的值时，结果不会被缓存。

* 对于InnoDB引擎来说，当一个语句在事务中修改了某个表，那么在这个事务 提交之前，所有与这个表相关

​        的查询都无法被缓存。因此长时间执行事务， 会大大降低缓存命中率。

* 查询的表是系统表 5，查询语句不涉及到表。

   查询缓存适用的场景：

   以读为主的业务，数据生成之后就不常改变的业务。比如门户类、新闻类、报表类、论坛类等。

3、查询优化处理

查询优化处理的三个阶段:

* 解析sql 通过lex词法分析,yacc语法分析将sql语句解析成解析树 https://www.ibm.com/developerworks/cn/linux/sdk/lex/ 

* 预处理阶段 根据mysql的语法的规则进一步检查解析树的合法性，如:检查数据的表和列是否存在，解析名字和别名的设置。还会进行权限的验证。
* 查询优化器 优化器的主要作用就是找到最优的执行计划。

查询优化器如何找到最优执行计划

* 使用等价变化规则

  5=5 and a>5 改写成a>5 

  a<b and a=5 改写成b>5 and a=5 

  基于联合索引，调整条件位置等

* 优化count、min、max等函数

  min函数只需找索引最左边

  max函数只需找索引最右边

  myisam引擎count(*) 

* 覆盖索引扫描

* 子查询优化

* 提前终止查询

  用了limit关键字或者使用不存在的条件 

* IN的优化

  先进性排序，再采用二分查找的方式

  OR->O(N)

  IN->O(logN)

​    Mysql的查询优化器是基于成本计算的原则。他会尝试各种执行计划。 数据抽样的方式进行试验(随机的读取一个4K的数据块进行分析) 

   执行计划

* id

  **select**查询的序列号，标识执行的顺序

  * id相同，执行顺序由上至下
  * id不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行
  * id相同又不同即两种情况同时存在，id如果相同，可以认为是一组，从上往下顺序
    执行;在所有组中，id值越大，优先级越高，越先执行

* select_type

  

  * SIMPLE:简单的select查询，查询中不包含子查询或者union

  * PRIMARY:查询中包含子部分，最外层查询则被标记为primary

  * SUBQUERY/MATERIALIZED:SUBQUERY表示在select 或 where列表中包含了子查询 

    MATERIALIZED表示where 后面in条件的子查询 

  * UNION:若第二个select出现在union之后，则被标记为union;
  * UNION RESULT:从union表获取结果的select

4、查询执行引擎

5、返回客户端

